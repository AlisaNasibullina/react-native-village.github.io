---
id: javascript11
title: Функции
sidebar_label: Функции
---

Функции нужны, чтобы не повторять один и тот же код во многих местах программного алгоритма. В современных программых `функции` являются основными «блоками».

Примеры системных функций вы уже видели. Давайте создавать свои.

## Объявление функции
Для создания функций мы можем использовать объявление функции.

Вначале идёт ключевое слово `function`, после него имя функции, затем список параметров в круглых скобках через запятую (в приведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.

Синтаксис:
```javascript
function имя(параметры) {
  ... тело ...  // Алгоритм
  return итоговоеЗначение;
}
```

Пример объявления функции без ключевого слова `return`:

```javascript
function message() {
   let str1 = 'Hello!'
}
```
Если честно, то это обыкновенная процедура, выполняющая последовательность комманд. В данном случае внутри тела находится единственная команда `let str1 = 'Hello!'`,где переменной `str1` присваивается значение `'Hello!'`.

Наша новая функция может быть вызвана по её имени (сама по себе) myMessage():

```javascript
function myMessage() {
   let str1 = 'Hello!'
   console.log(str1)
}

myMessage();
```
В данном примере функция срабатывает независимо (просто вызывается, `не присваивая возвращаемые параметры` кому-либо).

:::note Внимание ! 
Если `return` не указан, вместо него функция возвращает параметр `undefined` и по умолчанию считается, что функция заканчивается пустой заглушкой `return;`, выполняя лишь внутренние коды.
:::

### Вариант 1. Просто return
Чтобы функция, что-то возвращала, в теле указывают ключевое слово `return` (точка выхода или возврата результата) и возвращаемое значение.

```jsx live
function showNumberFive() {
    return 5
}
```
Поэскпериментируйте, поставте вместо исходной цифры количество Ваших лет.

:::tip Запомни!
Объявив функцию, а затем вызвав её, мы в любом случае получаем результат выполнения алгорима (заранее описанных действий) в теле функции.
:::

```jsx live
function learnJavaScript() {

  function showNumberFive() {
      return 17;
  }    
  let x = showNumberFive()
  return x
}    

```
Функция `showNumberFive()` вернет просто цифру 17 во внешнию переменную x, значение которой выведем через  функцию `learnJavaScript()`. Таким образом, внутри функции можно размещать другую функцию.

Давайте рассмотрим всё это шаг за шагом:
- Ключевое слово `function` указывает интерпретатору на то, что следующий далее код является пользовательской, то есть созданной Вами, а не встроенной, функцией.
- Написанное верблюжьимРегистром `showNumberFive` является пользовательским названием этой функции. Для интерпретатора в общем‑то нет разницы, как именно называется эта функция, но лучше давать функциям названия, из которых чётко следует, что именно они делают.
- `(Скобки с именами формальных переменных)` — обязательный элемент любой функции. Порой в скобки заключается одна, две и так далее переменных; в нашем случае в скобках нет ничего.
- В `{фигурные скобки}`, зачастую расположенные над ENTER, на клавише с [квадратными скобками], должно быть заключено само тело функции - суть алгоритма программы.
- Само тело функции принято выделять отступами справа (зачастую при помощи клавиши TAB); это не обязательно, но приветствуется, поскольку значительно облегчает работу.
- Ключевое слово `return` (их может быть несколько :) ) означает, что всякий раз, когда мы вызываем эту функцию, значение, которое сейчас же будет выведено (оно называется «возвращаемое значение функции»), будет передано (то есть «возвращено») интерпретатору.

### Вариант 2. Классика
```jsx live
function sum() {
   let x = 10;
   let y = 20;
   let z;
   z = x+y; // Алгоритм
   return z;
}
```
В функции `sum()` объявляются переменные ` x ` и ` y ` со значениями, объявляется переменная ` z ` и по заданному алгоритму производим расчет (сложение 2-х чисел), а результат выводим через return. 

Но обращаться к функции в дальнейшем будем всегда по имени, при необходимости несколько раз:
```javascript
let x1
x1=sum()

let y1
y1=sum()
```

Этот пример явно показывает одно из главных предназначений функций: избавление от дублирования кода. Функцию можно запускать множества раз.

:::tip Запомни!
Если понадобится поменять алгоритм или способ его вывода – достаточно изменить его в одном месте: в теле функции, которая его выводит.
:::

## Параметры и аргументы функций

Объявим ещё одну функцию, но уже с переменной в скобках.
Когда при функции в скобках есть ещё и переменная, мы будем называть её `формальным параметром` (заранее неопределенным, мы же не знаем чему будет равно значение x). У большей части функций будут параметры, но иногда нам встретятся функции и без них.
```javascript
function addThree(x) {
    if (x>10)    
      return x * 3
    else 
      return x + 3
}
```
После объявления функции и её параметров, мы можем вызвать (запустить) «блок кода» с конкретным значением (например: 5). 
Такое присваивание значения мы будем называть аргументом:
```javascript
addThree(5)

Ответ: 8
```
В нашем примере `цифра 5` является `аргументом функции` - конкретное передаваемое значение внутрь функции.
Как только наша функция получила свой аргумент, она тотчас же присвоила его значение переменной x (которое является формальным параметром нашей функции). 

Полный пример кода (можно поэкспериментировать):
```jsx live
function learnJavaScript() {

  function addThree(x) {
      return x + 3
  }

return addThree(5)
}
```

Далее в теле функции над параметром x была произведена математическая операция, и нам было возвращено через `return` в ответе новое значение.
Попробуйте шутки ради дать в качестве аргумента строку. Как думаете, что произойдёт?

:::note Внимание !
Сможете объяснить разницу между параметрами и аргументами? 

Если ещё нет, то вкратце она состоит в следующем: `аргумент` — это конкретное значение, которое мы «передали» функции при её вызове в скобочках. Это значение или набор значений присваивается `формальным параметрам` этой функции описанной в оригинале. 

Или так: `параметр` — это название переменной, указанное в объявлении функции и ожидающее присваивания конкретного значения в момент вызова функции. Присваиваемое параметру значение и есть аргумент. Всё понятно? Отлично. 
А ещё вот что: множество программистов используют эти термины (аргумент и параметр) взаимозаменяемо, но мы то разницу поняли.
:::

### Вариант 3. Расчет периметра
Давайте попробуем объявить функцию расчета по 2-м сторонам `периметра прямоугольника`, параметры которой будут ожидать двух чисел в качестве своего значения (обратите внимание, что если у вас более одного параметра, то их необходимо отделять друг от друга запятой).

```jsx live
function learnJavaScript() {

  function calcPrym(x, y) {
      let z
      z = 2*x + 2*y
      return z
  }
  return calcPrym(7, 42)
}
```
Когда мы вызовем эту функцию, мы должны будем задать ей в качестве аргументов два числа - значения сторон конкретного прямоугольника (отделённых друг от друга запятой):
```javascript
sumPrym(7, 8)

Ответ: 30
```
О, большое спасибо, компьютер!

Как Вы догадались передавая функции уже другие значения, она сразу посчитает периметры и других прямоугольников.

:::info Еще раз ) 
Одно из главных предназначений функций: избавление от дублирования кода и возможности его многократного вызова.
:::

## Встроенные функции

### console.log()
Так что давайте лучше употребим свои силы во имя добра! Например, вот секретный способ вывести (логгировать) в консоль отладочную информацию только для разработчиков (пользователи её увидеть не смогут; как вы знаете, большинство людей не подозревает даже о существовании самой консоли, а не то что о секретных «логах»!).

Нажмите в `браузере Google Chrome` сочетание клавиш `Ctrl + Shift + I` и на вкладке `Console` наберите:
```javascript
console.log('Совершенно секретно! Только для разработчиков!');
```
Как явствует из названия функции, мы выводим в консоль «лог» (то есть информацию о работе системы); этой доброй суперспособностью разработчики пользуются постоянно. Скажем, когда у вас были сообщения об ошибках, вы видели в консоли именно это — интерпретатор выдавал («логгировал») в консоль информацию о работе системы, чтобы вы могли прочесть и исправить нужные параметры. Словом, очень полезная штука. Вам не раз и не два придётся прибегнуть к помощи `console.log()`, так что запомните эту функцию!

```javascript
console.log('Выведите любое сообщение, какое пожелаете');
console.log('просто введите сюда какую‑нибудь ' + "строку");
let myMessage = 'А ещё в качестве аргумента можно использовать переменные!';
console.log(myMessage);
```
Пока вы играете с логами в консоли, я покажу вам ещё один трюк. Его мне поможет выполнить наш старый добрый друг — обратный слэш! 

При его содействии `\n` можно разбивать свой код по строчкам. Попробуйте сами:
```javascript
console.log('Можно разбить любой текст\n на многие\n строчки.');
console.log("Вот первая.\nА вот 2‑я.\n3‑я\n4‑я\n5‑я!");
```
Эта штука с \n вообще‑то имеет множество полезных практических применений. Например, можно нарисовать в кодировке ASCII мишку в консоли. Набирайте в консоли (всё в одну строку и внимательно проверяйте каждый /, \, пробел и всё такое):
```javascript
console.log(" c___c\n /. .\\\n \\_T_/\n /' '\\\n(/ . \\)\n/';‑;'\\\n()/ \\()");
```
Понятно, почему так выходит? 

Каждый `\n` задаёт переход на новую строчку, так что последующие символы как бы «спускаются» ниже, и вуаля! Мы с вами внесли серьёзный вклад в развитие общества нарисовали премилого мишку!


### Math.random()
А вот ещё одна очень полезная встроенная функция: Math.random(). Обратите внимание, что, в отличие от предыдущих, название этой функции начинается с прописной буквы `'M'`. Тому есть причины, приписные и строчные буквы в JavaScript различаются по внутренним кодам. 
В каждом языке, будь то русский, английский или JavaScript, всегда есть какие‑то исключения из правил. Вот это — одно из них. Все прочие переменные и функции, которые вы встретите в этой книге, следует писать со строчной буквы; помните, что регистр — это важная штука и, если название `Math.random()` начать с `math`, то функция просто не запустится.
```jsx live
function learnJavaScript() {

  return Math.random()

}
```
Каждый раз новое число! Функция выдаёт случайное вещественное число между 0 и 1.

Давайте модернизируем уравнение:
```jsx live
function learnJavaScript() {

  let x1 = Math.random()*100
  return x1

}
```

Если вам вдруг понадобится случайное число в диапазоне [0;100], то эта функция вам очень пригодится.

### Math.floor()
Эта функция требует число или цифру в качестве аргумента и, получив, `округляет их в меньшую сторону`, а `Math.round(x)` до ближайшего целого (то есть без каких‑либо десятых долей после запятой).
```jsx live
function learnJavaScript() {

  let x1 = Math.floor(10.7)        // 10
  let x2 = Math.round(4.8)         // 5
  let x3 = Math.floor(14.19723)    // 14

  return 'x1='+ x1 + ', x2=' + x2 + ', x3=' + x3
}
```

```javascript
  let num = 32.998; Math.floor(num)  // ?
```

### .toUpperCase()

Итак, НАЧНЁМ с ПРОСТОГО! Вы КОГДА‑НИБУДЬ замечали, ЧТО в НЕКОТОРЫХ сообщениях ЧЕРЕСЧУР много СЛОВ, выделенных ПРОПИСНЫМИ буквами?
Что ж, именно этому мы сейчас и научимся.

Вы можете запросто взять любую строку и вернуть её новую версию через прописные буквы (то есть в верхнем / нижнем регистре), используя встроенный метод `.toUpperCase() / .toLowerCase()`. И, соответственно, можно вернуть любую строку в строчных буквах (то есть в нижнем регистре). 

Помните, что `метод — это всего лишь функция`, прикреплённая к описанному объекту, в данном случае к универсальной строке. 

Работает это так:
```javascript
'Я люблю пиццу!'.toUpperCase();
"СЛУШАЙ, НУ ХВАТИТ УЖЕ ТАК ОРАТЬ.".toLowerCase();

let loginName = 'Саша';
let messageHello = "Как я рад тебя видеть, " + loginName + '!';
console.log(messageHello.toUpperCase() + ' Я так скучал!');
```
Есть вопросы? Нет? Отлично! Тогда едем дальше!


## А теперь всё вместе!
Попробуем замешать небольшой коктейль из только что выученных функций.

Если хотите, можете вполне обойтись и без `комментариев` (как обычно, начинаются с //), но не забывайте о `SHIFT+ENTER` для переноса! 
Для следующего этапа очень важно, чтобы всё, что мы пока написали, оставалось одним цельным блоком кода в консоли:
```jsx live
function learnJavaScript() {

  function logRandom() {
        // randomNumber - случайное число от 0 до 1
    let randomNumber = Math.random();
        // Умножим на 100 наше случайное число, чтобы получить число между [0 ; 100] сместив запятую на 2 разряда вправо
    let number100 = randomNumber * 100;
        // Применим Math.floor() для округления В МЕНЬШУЮ СТОРОНУ
    let task = 'Выбрано число от 0 до 100: ';
    let numberBig = Math.floor(number100);
        // Вывод результата
    return (task + numberBig);
  }

  return logRandom();   // Выбрано число от 0 до 100: 59
}
```

Надеюсь, ничего из сделанного не оказалось для вас трудной задачкой, и вы всё поняли. Если нет, то не торопясь просмотрите каждую строчку и комментарии к ней. Если же и после этого у вас остались вопросы, то советую вам вернуться к началу разговора о встроенных функциях и внимательно всё перечитать. Если и после этого какие‑то моменты остались неясны, тогда просто продолжайте
с нами до конца главы и, быть может, всё само прояснится по ходу дела.

Теперь можете победоносно `запускать функцию logRandom();` нажать ENTER и получать новый ответ. 

Оптимизируем нашу функцию, сразу в return (а `так делают очень часто` !) укажем без дополнительных переменных результат вычислений, объеденив строку 'Выбрано число от 0 до 100: ' с вложенным расчетом:

```jsx live
function learnJavaScript() {

function logRandom() {
    return 'Выбрано число от 0 до 100: ' + Math.floor(Math.random()*100)
}

return logRandom()   // Выбери число от 0 до 100: 48
}
```
Получилось? Очень надеюсь, что да! Информации уйма, так что не расстраивайтесь, если у вас не вышло с первого раза. Внимательно изучите весь код, убедитесь, что в нём нет никаких ошибок и опечаток. Внимательность — невероятно важный навык для программиста. Помните: «практически уверен» — это не уверен!

## Выбор имени функции
`Функция – это действие`. Поэтому имя функции обычно является глаголом. Оно должно быть простым, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются `глагольные префиксы`, обозначающие `общий характер действия`, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Например, функции, начинающиеся с `"show"` обычно что-то показывают.

Функции, начинающиеся с…
```javascript
"get.."     – возвращают значение,
"calc.."    – что-то вычисляют,
"create.."  – что-то создают,
"check.."   – что-то проверяют и возвращают логическое значение, и т.д.
```

Примеры таких имён:
```javascript
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```
Благодаря префиксам, при первом взгляде на имя функции становится понятным что делает её код, и какое значение она может возвращать.

В любом случае вы и ваша команда должны точно понимать, что значит префикс, что функция с ним может делать, а чего не может.

:::note Сверхкороткие имена функций
Имена функций, которые используются очень часто, иногда делают сверхкороткими.

Например, во фреймворке jQuery есть функция с именем `$`. В библиотеке Lodash основная функция представлена именем _.

Это исключения. В основном имена функций должны быть в меру краткими и описательными.
:::
### Функции == Комментарии
Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Cледовать этому правилу определённо полезно, особенно `в командной работе`.

Небольшие функции не только `облегчают тестирование и отладку` – само существование таких функций выполняет роль хороших комментариев.

## Локальные переменные
Переменные, объявленные внутри функции, видны только внутри этой функции.

Например:
```javascript
<!DOCTYPE html>
<script>
'use strict';

function myMessage() {
  let message = "Привет, я JavaScript!"; // локальная (внутренняя) переменная
  alert( message );
}

myMessage(); // Привет, я JavaScript!

alert( message ); // ошибка, т.к. переменная будет видна только внутри тела функции
</script>
```

## Внешние переменные

У функции есть доступ к внешним переменным, например:

```jsx live
function learnJavaScript() {

let userName = 'Sumerian School';

function myMessage() {
  let message = 'Привет, ' + userName + ' !';  // userName - внешняя переменная
  return message;
}

return myMessage(); // Привет, Sumerian School !
}
```

Функция обладает полным доступом к внешним переменным и может изменять их значение.

Например:
```jsx live
function learnJavaScript() {

let userName = 'Sumerian School';

function myMessage() {
  userName = "Школа программистов"; // изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  return message;
}

// userName = Sumerian School перед вызовом функции

myMessage();

// userName = Школа программистов, значение внешней переменной было изменено функцией
return 'Привет, ' + userName
}
```
Будте внимательны при обращении к внешним переменным.

## Стрелочные функции
Существует ещё более простой и краткий синтаксис для создания функций, который часто лучше, чем синтаксис Function Expression.

Итак, классический вариант записи функции:
### Вариант 4. Как объект

```javascript
function func1(arg1, arg2, ...argN) {
  return expression;
}
```
или через объявление функции как переменной-объектом:
```javascript
let func1 = function(arg1, arg2, ...argN) {
  return expression;
}
```

Такой код создаёт функцию `func1` с аргументами `arg1, .. argN` и вычисляет `expression - набор действий алгоритма` с правой стороны с их использованием, возвращая результат вычислений через ключевое слово `return`.
:::note Функция-объект 
Каждая функция JavaScript на самом деле является объектом функции. Это можно увидеть с помощью кода (function(){}).constructor === Function которая возвращает true.
:::

### Вариант 5. Стрелка =>
Но давайте применим `«функции-стрелки»` или `«стрелочные функции»` (arrow functions), т.к. выглядит следующим образом:

```javascript
let func1 = (arg1, arg2, ...argN) => expression
```

Другими словами, это более короткий вариант такой записи.
:::note Во как !
`=>` нам заменила { return ... } с правой сторны и позволяют не писать ключевое слово `function` с левой стороны !
:::

Давайте взглянем на конкретный пример:
```jsx live
function learnJavaScript() {

/* Исходная форма функции сложения 2-х чисел: */
let calcSum1 = function(a, b) {
  return a + b
};

// Стрелочная форма (нет слова `function` и `return`)
let calcSum2 = (a, b) => a + b

// console.log( calcSum1(5, 2) ); 
// console.log( calcSum2(5, 2) );
return calcSum1(5,2) + ' или ' + calcSum2(5,2)  // 7 или 7
}
```
Оба варианта правильны !

### Вариант 6. Только один аргумент
Если у нас только один аргумент, то `круглые скобки` вокруг параметров можно опустить, сделав запись ещё короче ` let num2 = n => n * 2 `
```jsx live
function learnJavaScript() {

/* Исходная форма функции сложения 2-х чисел: */
let num1 = function(n) 
  { return n * 2 }

// Стрелочная форма (нет слова `function` и `return`)
let num2 = n => n * 2

return num1(7) + ' или ' + num2(7)  // 14
}
```
### Вариант 7. Если нет аргументов
Если нет аргументов, то чтобы не получилось двойное ==, указываются `пустые круглые скобки`:

```jsx live
function learnJavaScript() {

let messHello = () => "Hello!"

return messHello()
}
```
Функции-стрелки могут быть использованы так же, как и Function Expression.

### Вариант 8. Безымянные функции
 Анонимные (безымянные) функции зачастую создаются и сразу же запускаются, так как находятся внутри колбэк функций. Еще одно важное отличие в том, что именованные функции объявляются, а анонимные создаются динамически. Анонимные функции могут выступать в качестве значения переменной.

Например, для динамического создания функции (смешанный стиль):
```javascript
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет') :
  () => alert("Здравствуйте!");

welcome(); // теперь всё в порядке
```
Внимательно проанализируйте данный код. Должно быть все понятно. Если нет, то разберитесь еше раз.


:::note "Взрыв мозга" !
Поначалу функции-стрелки могут показаться необычными и трудночитаемыми, но это быстро пройдёт, как только разум привыкнет к этим конструкциям.
:::
Они очень удобны для простых однострочных действий и выглядять очень компактно.


## Многострочные стрелочные функции
В примерах выше аргументы использовались слева от ` => `, а справа вычислялось выражение с их значениями.

Порой нам нужно что-то посложнее, например, выполнить `несколько инструкций подряд` в коде - сложный алгоритм. Это также возможно, нужно лишь заключить инструкции в фигурные скобки. И использовать `return` внутри них, как в обычной функции.

Например:
```jsx live
function learnJavaScript() {

let perimetr = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b
  result = 2*result
  // при фигурных скобках для возврата значения нужно явно вызвать return
  return result
};

return perimetr(5, 7)  // 24
}
```
Как Вы догодались подсчитан периметр прямоугольника по 2-м сторонам `a` и `b`. 

## Самовыполняющиеся функции
JavaScript позволяет создавать, кроме обычных и стрелочных, также и анонимные функции, выполняющие важную роль в JavaScript.

### Анонимные функции
Вы, скорее всего, уже встречались с анонимными функциями. Они входят в колбэк функции.
```javascript
document.getElementById("button").addEventListener("click", 
 function () {
  ...
 })
```
У функции в обработчике события `нет имени`, она `анонимна`. Анонимные функции зачастую создаются и `сразу же запускаются`, так как находятся внутри колбэк функций. Еще одно важное отличие в том, что именованные функции объявляются, а анонимные создаются при помощи оператора function. Анонимные функции могут выступать `в качестве значения переменной`:
```javascript
var luke = function() {
  // используй код
}
```
Таким образом, к функции можно обращаться по переменной, но сама функция остается анонимной! 
В качестве значения переменной также можно указать именованную функцию. С анонимными функциями все то же самое, они даже лучше подходят для таких целей.

### Отличие от обычных функций
Важное отличие анонимных функций в том, что они должны объявляться до их вызова. Можете вспомнить начало статьи. Там описывались обычные функции, их можно объявлять и вызывать в любом месте. Браузер парсит код перед его выполнением, подхватывая именованные функции по пути. 

Сам факт того, что функции должны прописываться в начале скрипта, лишь условность и хорошая практика программирования. 

`Анонимная функция` создается `в момент ее запуска` в скрипте, `не во время парсинга`, поэтому ее нельзя прописать после ее вызова в коде.

### Способы применения анонимных функций
У анонимных функций нет имени, поэтому они короче и их легче писать, если вам не нужно ссылаться на них в коде. По этой причине их и используют в колбэк функциях. Есть еще одна интересная особенность: в определенной записи такие функции могут вызывать сами себя.

```javascript
(function() {
    // код выполняется автоматически
})();
```
Техника называется самовыполняющиеся функции. Эффект создается пустыми скобками в конце функции, которые говорят браузеру, что эту функцию необходимо запустить как можно быстрее. Такая запись может показаться лишней, обычный JS также запустит функцию, когда дойдет до нее в коде. Так зачем использовать такую странную запись?

### Область видимости функции
Главная причина – область видимости функции. Можете вспомнить из прошлой статьи (cтандартные функции), что переменная, объявленная внутри функции, может быть вызвана только внутри этой функции. В остальном коде данная переменная не видна. 

Точно так же переменная внутри самовыполняющейся функции замыкается внутри этой функции. Такую переменную `нельзя случайно вызвать` из внешнего кода или переписать - это `повышает безопастность кода`. 

Такая техника аккуратно инкапсулирует переменные и код, пряча их от глобального пространства имен, чтобы они не вступили в конфликт с другим кодом. По такой же схеме часто пишутся полифилы и плагины, в виде самовыполняющихся функций.

## Заключение
Поняв суть стрелочных и обычных функций, вы сможете передавать функции в объекты-переменные и перестроить код по модулям. Функции такого рода можно использовать также и для создания и возврата других функций. Тут речь уже заходит о замыкании, о котором мы поговорим в следующей статье.


## Вопросы:

Объявление функции имеет вид (1, 2 или 3)?
- function имя (параметры, через, запятую) {
  // тело, код функции
}

- procedure имя (параметры) {
  // тело, код функции
}

- let имя (параметры) {}

Точка выхода или возврата результата в фнкции ?
- Esc
- return
- Hello

Ключевое слово return внутри тела функции:
- обязательна
- не обязательна

Ключевое слово return в теле функции может быть:
- Только 1 раз
- Не более 3-х раз
- Множества раз

Формальные переменные объявляются?
- Вне тела функции
- В скобочках после имени функции
- Внутри тела функции

Встроенные функции (правильных ответов может быть несколько)?
- console.log()
- myMessage()
- Math.random()

Стрелочные функции используют синтаксис?
- Вперед()
- =>
- go.Стрелка

Использование стрелочных функций позволяет?
- писать код компакто и более безопасно
- увеличивает структуру кода
- позволяет использовать новые переменные

Для того чтобы понять, на сколько вы усвоили этот урок, пройдите тест в [мобильном приложении](http://onelink.to/njhc95) нашей школы по этой теме.

## Ссылки:

1. [MDN web docs - Function](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function)
2. [Learn.javascript.ru - Статья "Функции"](https://learn.javascript.ru/function-basics)
3. [Learn.javascript.ru - Статья "Функции-стрелки"](https://learn.javascript.ru/arrow-functions-basics)
4. [Анонимные и самовыполняющиеся функции в JavaScript](https://webformyself.com/anonimnye-i-samovypolnyayushhiesya-funkcii-v-javascript/)
5. [Developer.mozilla.org - Статья "Math"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math)
6. [Developer.mozilla.org - Статья "Стрелочные функции"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
7. [Basicweb.ru - Статья "JavaScript функции"](https://basicweb.ru/javascript/js_function.php)
8. [Javascript.ru - Статья "Функции"](https://javascript.ru/basic/functions)
9. [Код для подростков: прекрасное руководство по программированию для начинающих, том 1: Javascript - Jeremy Moritz ](https://www.amazon.com/Code-Teens-Beginners-Programming-Javascript-ebook/dp/B07FCTLVPC)
## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/KoDim-React"><img src="https://avatars1.githubusercontent.com/u/72087863?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy K.</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">📖</a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->

[![Become a Patron!](/img/logo/patreon.png)](https://www.patreon.com/bePatron?u=31769291)

